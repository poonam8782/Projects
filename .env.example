# Copy this file to .env and fill in your actual values
# Never commit .env to version control

# Supabase Configuration
SUPABASE_URL=https://your-project.supabase.co
SUPABASE_ANON_KEY=your-anon-key-here
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key-here
SUPABASE_DB_URL=postgresql://postgres:your-db-password@db.your-project.supabase.co:5432/postgres  # Used by migrate.sh (raw SQL path). Use the DB password from Supabase Settings → Database (NOT the service role key).
SUPABASE_ANON_KEY=your-anon-key-here  # Used by backend HS256 fallback verification

# Gemini AI Configuration
GEMINI_API_KEY=your-gemini-api-key-here

# Backend Configuration
BACKEND_URL=http://localhost:8000
CORS_ORIGINS=http://localhost:3000,https://your-production-domain.com

# Frontend Configuration
NEXT_PUBLIC_SUPABASE_URL=https://your-project.supabase.co
NEXT_PUBLIC_SUPABASE_ANON_KEY=your-anon-key-here
NEXT_PUBLIC_BACKEND_URL=http://localhost:8000

# Optional - Monitoring
SENTRY_DSN=
POSTHOG_API_KEY=

# Database Setup
# Before running the app, apply the database schema:
#   cd infra/supabase && ./migrate.sh
# This creates tables with pgvector extension and RLS policies
# See infra/supabase/README.md for details
# Alternatively, use Supabase CLI migrations:
#   supabase link --project-ref <project-ref>
#   supabase db push

# Authentication Setup
# Frontend uses NEXT_PUBLIC_SUPABASE_URL + NEXT_PUBLIC_SUPABASE_ANON_KEY for anon client (RLS enforced).
# Backend uses SUPABASE_SERVICE_ROLE_KEY for privileged operations (bypasses RLS) – do NOT expose to frontend.
# JWTs are verified on backend via JWKS (RS256) or fallback to /auth/v1/user (HS256 legacy).
# Next.js middleware auto-refreshes tokens; React AuthContext provides client state.
